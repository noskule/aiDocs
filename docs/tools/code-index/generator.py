"""Markdown generation for code-index tool."""

from __future__ import annotations

from pathlib import Path

from grouping import PackageGroup
from languages.base import Declaration


def generate_root_index(modules: list[dict], output_dir: Path) -> None:
    """Generate the top-level index.md listing all modules.

    Args:
        modules: List of dicts with 'name', 'groups' (list of PackageGroup), 'decl_count'.
        output_dir: Root output directory for code-index.
    """
    lines = [
        "# Code Index",
        "",
        "> Auto-generated by [code-index](../tools/code-index/). Do not edit manually.",
        "",
        "## Modules",
        "",
        "| Module | Packages | Declarations |",
        "|--------|----------|--------------|",
    ]

    for mod in modules:
        name = mod["name"]
        pkg_count = len(mod["groups"])
        decl_count = mod["decl_count"]
        lines.append(f"| [{name}]({name}/index.md) | {pkg_count} | {decl_count} |")

    lines.append("")

    output_dir.mkdir(parents=True, exist_ok=True)
    (output_dir / "index.md").write_text("\n".join(lines), encoding="utf-8")


def generate_module_index(
    module_name: str,
    groups: list[PackageGroup],
    output_dir: Path,
) -> None:
    """Generate per-module index.md with one-line summaries per package.

    Args:
        module_name: Module name (e.g., "android").
        groups: Sorted list of PackageGroup objects for this module.
        output_dir: Root output directory for code-index.
    """
    module_dir = output_dir / module_name
    module_dir.mkdir(parents=True, exist_ok=True)

    lines = [
        f"# {module_name} — Code Index",
        "",
        "> Auto-generated by [code-index](../../tools/code-index/). Do not edit manually.",
        "",
    ]

    for group in groups:
        file_name = group.file_name
        lines.append(f"## [{group.package}]({file_name})")
        lines.append("")

        for decl in group.declarations:
            summary = _one_liner(decl)
            lines.append(summary)

        lines.append("")

    (module_dir / "index.md").write_text("\n".join(lines), encoding="utf-8")


def generate_package_file(
    module_name: str,
    group: PackageGroup,
    output_dir: Path,
) -> None:
    """Generate per-package .md file with full signatures and members.

    Args:
        module_name: Module name (e.g., "android").
        group: PackageGroup to render.
        output_dir: Root output directory for code-index.
    """
    module_dir = output_dir / module_name
    file_path = module_dir / group.file_name
    file_path.parent.mkdir(parents=True, exist_ok=True)

    lines = [
        f"# {group.package}",
        "",
        "> Auto-generated by [code-index](../../tools/code-index/). Do not edit manually.",
        "",
    ]

    for decl in group.declarations:
        lines.extend(_render_declaration(decl))
        lines.append("")

    file_path.write_text("\n".join(lines), encoding="utf-8")


# ── One-liner for module index ──────────────────────────────────────


def _one_liner(decl: Declaration) -> str:
    """Generate a one-line summary for the module index."""
    ann_str = ""
    if decl.annotations:
        ann_str = " " + " ".join(f"`@{a}`" for a in decl.annotations)

    kind_label = decl.kind
    if kind_label in ("val", "var", "fun"):
        kind_label = ""

    doc_part = ""
    if decl.doc_summary:
        doc_part = f" — {decl.doc_summary}"

    if kind_label:
        return f"- **{decl.name}** *{kind_label}*{ann_str}{doc_part}"
    else:
        return f"- **{decl.name}**{ann_str}{doc_part}"


# ── Full declaration rendering ──────────────────────────────────────


def _render_declaration(decl: Declaration) -> list[str]:
    """Render a full declaration block for the per-package file."""
    lines = []

    # Header
    ann_str = ""
    if decl.annotations:
        ann_str = " " + " ".join(f"`@{a}`" for a in decl.annotations)
    lines.append(f"## {decl.name}{ann_str}")
    lines.append("")

    # Kind badge and doc
    if decl.doc_summary:
        lines.append(f"{decl.doc_summary}")
        lines.append("")

    # Source file
    lines.append(f"`{decl.file_path}`")
    lines.append("")

    # Signature
    lines.append(f"```kotlin")
    lines.append(decl.signature)
    lines.append("```")
    lines.append("")

    # Children grouped by kind
    if decl.children:
        functions = [c for c in decl.children if c.kind == "fun"]
        properties = [c for c in decl.children if c.kind in ("val", "var")]
        nested = [c for c in decl.children if c.kind not in ("fun", "val", "var")]

        if properties:
            lines.append("### Properties")
            lines.append("")
            for prop in properties:
                lines.append(_render_member(prop))
            lines.append("")

        if functions:
            lines.append("### Functions")
            lines.append("")
            for func in functions:
                lines.append(_render_member(func))
            lines.append("")

        if nested:
            lines.append("### Nested Types")
            lines.append("")
            for n in nested:
                doc_part = f" — {n.doc_summary}" if n.doc_summary else ""
                lines.append(f"- **{n.name}** *{n.kind}*{doc_part}")
            lines.append("")

    return lines


def _render_member(member: Declaration) -> str:
    """Render a single class member as a bullet point."""
    doc_part = f" — {member.doc_summary}" if member.doc_summary else ""
    return f"- `{member.signature}`{doc_part}"
